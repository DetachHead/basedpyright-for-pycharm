{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pyright for PyCharm user documentation","text":"<p>This plugin provides Pyright integration for PyCharm.</p>"},{"location":"#screenshots","title":"Screenshots","text":""},{"location":"configurations/","title":"Configurations","text":""},{"location":"configurations/#generic","title":"Generic","text":""},{"location":"configurations/#executable","title":"Executable","text":"<p>For the plugin to work, you need to define at least one executable file using either the Global or Project panel.</p> <p>Such a file is typically named <code>pyright</code>/<code>pyright-python</code> (preferably the former, if you have both) and can be found in:</p> <ul> <li>Global: Your Python interpreter directory</li> <li>Virtual environment: <code>/venv/Scripts/</code> (Windows) or <code>/venv/bin</code> (Linux)</li> </ul> <p>You can also use a relative path. It would be interpreted as relative to the project directory.</p> <p>The executable is used as-is with no additional checks, so the plugin will still work even if, for example, it's a wrapper script that outputs the same diagnostics.</p>"},{"location":"configurations/#configuration-file","title":"Configuration file","text":"<p>Despite being called \"file\", this can be a path to a directory containing <code>pyright-config.json</code> and/or <code>pyproject.toml</code>. This path will be passed to the executable via the <code>-p</code> option.</p> <ul> <li>If the executable is local, only the local path is used.</li> <li>If the executable is global, the local path is used if it is specified,   falling back to the global one.</li> </ul> <p>If the path retrieved using the aforementioned strategy is not specified, the project directory is used.</p>"},{"location":"configurations/#global","title":"Global","text":""},{"location":"configurations/#always-use-global","title":"Always use global","text":"<p>Check this option to always use the global executable and configuration file.</p> <p>Default: <code>false</code></p>"},{"location":"configurations/#use-editor-font","title":"Use editor font","text":"<p>Check this option to display annotations in your editor font. This option is not applied retroactively; you might need make an edit to see the effect.</p> <p>Default: <code>false</code></p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#frequently-asked-questions","title":"Frequently asked questions","text":""},{"location":"faq/#what-exactly-is-this-plugin-doing","title":"What exactly is this plugin doing?","text":"<p>In a nutshell:</p> <ul> <li>You edit your code.</li> <li>This plugin saves your (unsaved) files.</li> <li>It then invokes the executable provided by you with some hardcoded arguments.</li> <li>The results of which are used to show annotations.</li> </ul> <p>And that's it.</p> <p>It expects two things:</p> <ul> <li>That the executable you provide accepts said arguments, and</li> <li>that it outputs diagnostics in the formats specified here.</li> </ul> <p>As long as you respect these requirements, you can use your own script, or whatever. If you don't, expect some big bad error messages. </p>"},{"location":"faq/#my-code-should-have-nothese-errors-but-it-doesdoesnt","title":"My code should have no/these errors, but it does/doesn't.","text":"<p>This plugin contains no type checking logic. For type checking bugs, please report them to the Pyright issue tracker.</p>"},{"location":"faq/#whats-the-difference-between-pyright-and-pyright-python","title":"What's the difference between <code>pyright</code> and <code>pyright-python</code>?","text":"<p>Pyright is written in TypeScript and published on NPM, mainly for the purpose of better integration with VSCode. This requires a dependency on Node, which Python developers might not have on their development machines.</p> <p>The <code>pyright</code> package on PyPI was created to solve this problem. It automatically installs the actual NPM package and places the original executables, named <code>pyright</code>/<code>pyright-langserver</code>, inside the same virtual environment/directory as its own proxies <code>pyright-python</code>/<code>pyright-python-langserver</code>.</p> <p>These proxies will re-output the results of the original executables. With the correct configurations, running the proxies will also update the originals.</p> <p>While the command-line interfaces are expected to be the same, it might not be the case. Thus, you are recommended to use the originals if you have them.</p>"},{"location":"faq/#why-does-this-plugin-have-to-perform-saves-so-often","title":"Why does this plugin have to perform saves so often?","text":"<p>Pyright does not support passing files from stdin. A feature request was made and quickly rejected.</p> <p>Adding an option that makes the plugin run only on \"manual\" saves is counter-productive. You have to save all your files manually, or wait until PyCharm saves them automatically. Neither is convenient.</p> <p>If you use PyCharm Professional, you should be using the sister plugin instead. It relies on experimental APIs and thus not as stable, but much faster and does not require saving.</p>"},{"location":"faq/#is-watch-mode-watch-supported","title":"Is watch mode (<code>--watch</code>) supported?","text":"<p>Supporting for watch mode is on the roadmap. There is no ETA, however.</p>"},{"location":"faq/#why-does-it-take-so-long-to-run-on-my-project","title":"Why does it take so long to run on my project?","text":"<p>Since this plugin invokes a CLI tool, it must be registered as an <code>ExternalAnnotator</code>. Inspectors of this kind are only run when all other background tasks have finished.</p> <p>Unlike Mypy, Pyright does not cache previous results in a hidden directory. As such, everytime it runs on a given file, it also has to reprocess all other files that file depends on.</p> <p>Again, for better performance, the sister plugin is recommended.</p>"}]}